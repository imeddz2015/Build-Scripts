--- cpan/Compress-Raw-Zlib/zlib-src/zutil.c
+++ cpan/Compress-Raw-Zlib/zlib-src/zutil.c
@@ -42,70 +42,70 @@
     }
     switch ((int)(sizeof(uLong))) {
     case 2:     break;
-    case 4:     flags += 1 << 2;        break;
-    case 8:     flags += 2 << 2;        break;
-    default:    flags += 3 << 2;
+    case 4:     flags += 1U << 2;        break;
+    case 8:     flags += 2U << 2;        break;
+    default:    flags += 3U << 2;
     }
     switch ((int)(sizeof(voidpf))) {
     case 2:     break;
-    case 4:     flags += 1 << 4;        break;
-    case 8:     flags += 2 << 4;        break;
-    default:    flags += 3 << 4;
+    case 4:     flags += 1U << 4;        break;
+    case 8:     flags += 2U << 4;        break;
+    default:    flags += 3U << 4;
     }
     switch ((int)(sizeof(z_off_t))) {
     case 2:     break;
-    case 4:     flags += 1 << 6;        break;
-    case 8:     flags += 2 << 6;        break;
-    default:    flags += 3 << 6;
+    case 4:     flags += 1U << 6;        break;
+    case 8:     flags += 2U << 6;        break;
+    default:    flags += 3U << 6;
     }
 #ifdef ZLIB_DEBUG
-    flags += 1 << 8;
+    flags += 1UL << 8;
 #endif
 #if defined(ASMV) || defined(ASMINF)
-    flags += 1 << 9;
+    flags += 1UL << 9;
 #endif
 #ifdef ZLIB_WINAPI
-    flags += 1 << 10;
+    flags += 1UL << 10;
 #endif
 #ifdef BUILDFIXED
-    flags += 1 << 12;
+    flags += 1UL << 12;
 #endif
 #ifdef DYNAMIC_CRC_TABLE
-    flags += 1 << 13;
+    flags += 1UL << 13;
 #endif
 #ifdef NO_GZCOMPRESS
-    flags += 1L << 16;
+    flags += 1UL << 16;
 #endif
 #ifdef NO_GZIP
-    flags += 1L << 17;
+    flags += 1UL << 17;
 #endif
 #ifdef PKZIP_BUG_WORKAROUND
-    flags += 1L << 20;
+    flags += 1UL << 20;
 #endif
 #ifdef FASTEST
-    flags += 1L << 21;
+    flags += 1UL << 21;
 #endif
 #if defined(STDC) || defined(Z_HAVE_STDARG_H)
 #  ifdef NO_vsnprintf
-    flags += 1L << 25;
+    flags += 1UL << 25;
 #    ifdef HAS_vsprintf_void
-    flags += 1L << 26;
+    flags += 1UL << 26;
 #    endif
 #  else
 #    ifdef HAS_vsnprintf_void
-    flags += 1L << 26;
+    flags += 1UL << 26;
 #    endif
 #  endif
 #else
-    flags += 1L << 24;
+    flags += 1UL << 24;
 #  ifdef NO_snprintf
-    flags += 1L << 25;
+    flags += 1UL << 25;
 #    ifdef HAS_sprintf_void
-    flags += 1L << 26;
+    flags += 1UL << 26;
 #    endif
 #  else
 #    ifdef HAS_snprintf_void
-    flags += 1L << 26;
+    flags += 1UL << 26;
 #    endif
 #  endif
 #endif
--- op.c
+++ op.c
@@ -13542,7 +13542,7 @@
             op_sibling_splice(parent, first, -1, NULL);
 	op_free(entersubop);
 
-	if (cvflags == (OP_ENTEREVAL | (1<<16)))
+	if (cvflags == (OP_ENTEREVAL | (1U<<16)))
 	    flags |= OPpEVAL_BYTES <<8;
 	
 	switch (PL_opargs[opnum] & OA_CLASS_MASK) {
--- regcomp.c
+++ regcomp.c
@@ -334,7 +334,7 @@
 
 
 #define PBYTE(u8str,paren) ((U8*)(u8str))[(paren) >> 3]
-#define PBITVAL(paren) (1 << ((paren) & 7))
+#define PBITVAL(paren) (1U << ((paren) & 7))
 #define PAREN_TEST(u8str,paren) ( PBYTE(u8str,paren) & PBITVAL(paren))
 #define PAREN_SET(u8str,paren) PBYTE(u8str,paren) |= PBITVAL(paren)
 #define PAREN_UNSET(u8str,paren) PBYTE(u8str,paren) &= (~PBITVAL(paren))
@@ -19983,7 +19983,7 @@
     ASSUME(REG_INTFLAGS_NAME_SIZE <= sizeof(flags)*8);
 
     for (bit=0; bit<REG_INTFLAGS_NAME_SIZE; bit++) {
-        if (flags & (1<<bit)) {
+        if (flags & (1U<<bit)) {
             if (!set++ && lead)
                 Perl_re_printf( aTHX_  "%s", lead);
             Perl_re_printf( aTHX_  "%s ", PL_reg_intflags_name[bit]);
@@ -20007,8 +20007,8 @@
     ASSUME(REG_EXTFLAGS_NAME_SIZE <= sizeof(flags)*8);
 
     for (bit=0; bit<REG_EXTFLAGS_NAME_SIZE; bit++) {
-        if (flags & (1<<bit)) {
-	    if ((1<<bit) & RXf_PMf_CHARSET) {	/* Output separately, below */
+        if (flags & (1U<<bit)) {
+	    if ((1U<<bit) & RXf_PMf_CHARSET) {	/* Output separately, below */
 		continue;
 	    }
             if (!set++ && lead)
--- vms/vms.c
+++ vms/vms.c
@@ -11145,7 +11145,7 @@
       sockflagsize = fdoff + 2;
     }
     if (fstat(fd, &sbuf.crtl_stat) == 0 && S_ISSOCK(sbuf.st_mode))
-      sockflags[fdoff] |= 1 << (fd % sizeof(unsigned int));
+      sockflags[fdoff] |= 1U << (fd % sizeof(unsigned int));
   }
   return fp;
 
@@ -11166,7 +11166,7 @@
     unsigned int fdoff = fd / sizeof(unsigned int);
 
     if (sockflagsize && fdoff < sockflagsize)
-      sockflags[fdoff] &= ~(1 << fd % sizeof(unsigned int));
+      sockflags[fdoff] &= ~(1U << fd % sizeof(unsigned int));
   }
   return fclose(fp);
 }
@@ -11193,7 +11193,7 @@
   int bufsize = itmsz * nitm + 1;
 
   if (fdoff < sockflagsize &&
-      (sockflags[fdoff] | 1 << (fd % sizeof(unsigned int)))) {
+      (sockflags[fdoff] | 1U << (fd % sizeof(unsigned int)))) {
     if (write(fd, src, itmsz * nitm) == EOF) return EOF;
     return nitm;
   }
--- pp.c
+++ pp.c
@@ -32,6 +32,13 @@
 #include "reentr.h"
 #include "regcharclass.h"
 
+/* Inline ASM due to undefined buhavior and testing with UBsan. ASM does
+ * not suffer C rules. See https://github.com/Perl/perl5/issues/17508.
+ */
+#if defined(__GNUC__) || defined(__clang__) || defined(__INTEL_COMPILER)
+# define GCC_INLINE_ASM 1
+#endif
+
 /* variations on pp_null */
 
 PP(pp_stub)
@@ -2618,7 +2625,17 @@
     tryAMAGICbin_MG(mult_amg, AMGf_assign);
     {
       dPOPTOPiirl_nomg;
+#if defined(GCC_INLINE_ASM) && (defined(__x86_64__) || defined(__amd64__))
+      long int res;
+      __asm__ ("imulq %2, %%rax;" : "=a" (res) : "a" (left), "g" (right) : "rdx", "cc" );
+      SETi( res );
+#elif defined(GCC_INLINE_ASM) && (defined(__i386__) || defined(__i686__))
+      long int res;
+      __asm__ ("imull %2, %%eax;" : "=a" (res) : "a" (left), "g" (right) : "edx", "cc" );
+      SETi( res );
+#else
       SETi( left * right );
+#endif
       RETURN;
     }
 }
@@ -2637,10 +2654,25 @@
 
       /* avoid FPE_INTOVF on some platforms when num is IV_MIN */
       if (value == -1)
-          value = - num;
+          value = -(unsigned long int)num;
       else
-          value = num / value;
-      SETi(value);
+#if defined(GCC_INLINE_ASM) && (defined(__x86_64__) || defined(__amd64__))
+      {
+          long int res;
+          __asm__ ("xorq %%rdx, %%rdx; idivq %2;" : "=a" (res) : "a" (num), "g" (value) : "rdx", "cc" );
+          SETi( res );
+      }
+#elif defined(GCC_INLINE_ASM) && (defined(__i386__) || defined(__i686__))
+      {
+          long int res;
+          __asm__ ("xorl %%edx, %%edx; idivl %2;" : "=a" (res) : "a" (num), "g" (value) : "edx", "cc" );
+          SETi( res );
+      }
+#else
+      {
+          SETi(num / value);
+      }
+#endif
       RETURN;
     }
 }
@@ -2654,11 +2686,28 @@
 	  dPOPTOPiirl_nomg;
 	  if (!right)
 	       DIE(aTHX_ "Illegal modulus zero");
+
 	  /* avoid FPE_INTOVF on some platforms when left is IV_MIN */
 	  if (right == -1)
 	      SETi( 0 );
 	  else
+#if defined(GCC_INLINE_ASM) && (defined(__x86_64__) || defined(__amd64__))
+	  {
+	      long int res;
+	      __asm__ ("xorq %%rdx, %%rdx; idivq %2;" : "=d" (res) : "a" (left), "g" (right) : "cc" );
+	      SETi( res );
+	  }
+#elif defined(GCC_INLINE_ASM) && (defined(__i386__) || defined(__i686__))
+	  {
+	      long int res;
+	      __asm__ ("xorl %%edx, %%edx; idivl %2;" : "=d" (res) : "a" (left), "g" (right) : "cc" );
+	      SETi( res );
+	  }
+#else
+	  {
 	      SETi( left % right );
+	  }
+#endif
 	  RETURN;
      }
 }
@@ -2693,7 +2742,17 @@
     tryAMAGICbin_MG(add_amg, AMGf_assign);
     {
       dPOPTOPiirl_ul_nomg;
+#if defined(GCC_INLINE_ASM) && (defined(__x86_64__) || defined(__amd64__))
+      long int res;
+      __asm__ ("addq %2, %%rax;" : "=a" (res) : "a" (left), "g" (right) : "cc" );
+      SETi( res );
+#elif defined(GCC_INLINE_ASM) && (defined(__i386__) || defined(__i686__))
+      long int res;
+      __asm__ ("addl %2, %%eax;" : "=a" (res) : "a" (left), "g" (right) : "cc" );
+      SETi( res );
+#else
       SETi( left + right );
+#endif
       RETURN;
     }
 }
@@ -2704,7 +2763,17 @@
     tryAMAGICbin_MG(subtr_amg, AMGf_assign);
     {
       dPOPTOPiirl_ul_nomg;
+#if defined(GCC_INLINE_ASM) && (defined(__x86_64__) || defined(__amd64__))
+      long int res;
+      __asm__ ("subq %2, %%rax;" : "=a" (res) : "a" (left), "g" (right) : "cc" );
+      SETi( res );
+#elif defined(GCC_INLINE_ASM) && (defined(__i386__) || defined(__i686__))
+      long int res;
+      __asm__ ("subl %2, %%eax;" : "=a" (res) : "a" (left), "g" (right) : "cc" );
+      SETi( res );
+#else
       SETi( left - right );
+#endif
       RETURN;
     }
 }
@@ -2802,7 +2871,7 @@
     {
 	SV * const sv = TOPs;
 	IV const i = SvIV_nomg(sv);
-	SETi(-i);
+	SETi( -(unsigned long int)i );
 	return NORMAL;
     }
 }
